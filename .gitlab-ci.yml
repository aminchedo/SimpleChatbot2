stages:
  - prepare
  - test
  - build
  - security
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  DOCKER_IMAGE_LATEST: $CI_REGISTRY_IMAGE:latest
  NODE_VERSION: "18"
  PYTHON_VERSION: "3.11"
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.pip-cache"

# Global cache settings
.cache_template: &cache_template
  cache:
    key: "$CI_COMMIT_REF_SLUG"
    paths:
      - frontend/node_modules/
      - frontend/.npm/
      - .pip-cache/
      - backend/.venv/
    policy: pull-push

# Services
services:
  - docker:dind

# Before script for Docker authentication
before_script:
  - docker info
  - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY

# Prepare stage - Install and cache all dependencies
prepare_frontend:
  stage: prepare
  image: node:${NODE_VERSION}-alpine
  <<: *cache_template
  before_script:
    - apk add --no-cache git python3 make g++
  script:
    - cd frontend
    - npm ci --cache .npm --prefer-offline --no-audit
    - npm ls || true  # List installed packages for debugging
  artifacts:
    paths:
      - frontend/node_modules/
    expire_in: 1 hour
  only:
    - merge_requests
    - main
    - develop

prepare_backend:
  stage: prepare
  image: python:${PYTHON_VERSION}-alpine
  <<: *cache_template
  before_script:
    - apk add --no-cache git gcc musl-dev libffi-dev python3-dev build-base curl
    - python -m venv backend/.venv
    - source backend/.venv/bin/activate
    - pip install --upgrade pip setuptools wheel
  script:
    - cd backend
    - source .venv/bin/activate
    - pip install --cache-dir $PIP_CACHE_DIR -r requirements.txt
    - pip list  # List installed packages for debugging
  artifacts:
    paths:
      - backend/.venv/
    expire_in: 1 hour
  only:
    - merge_requests
    - main
    - develop

# Lint and code quality checks
lint_frontend:
  stage: test
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - prepare_frontend
  script:
    - cd frontend
    - npm run lint --if-present || echo "No lint script found"
    - npm run type-check --if-present || echo "No type-check script found"
  only:
    - merge_requests
    - main
    - develop

lint_backend:
  stage: test
  image: python:${PYTHON_VERSION}-alpine
  dependencies:
    - prepare_backend
  before_script:
    - apk add --no-cache git gcc musl-dev libffi-dev python3-dev build-base
  script:
    - cd backend
    - source .venv/bin/activate
    - pip install flake8 black isort mypy --cache-dir $PIP_CACHE_DIR
    - flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || echo "Flake8 warnings found"
    - black --check . || echo "Black formatting issues found"
    - isort --check-only . || echo "Import sorting issues found"
    - mypy . --ignore-missing-imports || echo "MyPy type checking warnings found"
  allow_failure: true
  only:
    - merge_requests
    - main
    - develop

# Test stage with automatic dependency installation
test_frontend:
  stage: test
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - prepare_frontend
  before_script:
    - apk add --no-cache chromium
    - export PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true
    - export CHROMIUM_PATH=/usr/bin/chromium-browser
  script:
    - cd frontend
    - npm run test:ci --if-present || npm test --if-present || echo "No tests found"
  coverage: '/Lines\s*:\s*(\d+\.\d+)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: frontend/coverage/cobertura-coverage.xml
    paths:
      - frontend/coverage/
    expire_in: 1 week
  only:
    - merge_requests
    - main
    - develop

test_backend:
  stage: test
  image: python:${PYTHON_VERSION}-alpine
  dependencies:
    - prepare_backend
  services:
    - redis:alpine
  variables:
    REDIS_URL: "redis://redis:6379"
    ENVIRONMENT: "test"
  before_script:
    - apk add --no-cache git gcc musl-dev libffi-dev python3-dev build-base curl
  script:
    - cd backend
    - source .venv/bin/activate
    - pip install pytest pytest-cov pytest-asyncio --cache-dir $PIP_CACHE_DIR
    - python -m pytest tests/ --cov=. --cov-report=xml --cov-report=term-missing || echo "No tests found or tests failed"
  coverage: '/TOTAL.+?(\d+\%)$/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: backend/coverage.xml
    paths:
      - backend/htmlcov/
    expire_in: 1 week
  only:
    - merge_requests
    - main
    - develop

# Security scanning
security_scan:
  stage: security
  image: python:${PYTHON_VERSION}-alpine
  dependencies:
    - prepare_frontend
    - prepare_backend
  before_script:
    - apk add --no-cache nodejs npm git gcc musl-dev libffi-dev python3-dev build-base
  script:
    # Frontend security scan
    - cd frontend && npm audit --audit-level=high || echo "Frontend audit warnings found"
    
    # Backend security scan
    - cd ../backend
    - source .venv/bin/activate
    - pip install safety bandit --cache-dir $PIP_CACHE_DIR
    - safety check --cache-dir $PIP_CACHE_DIR || echo "Safety check completed with warnings"
    - bandit -r . -f json -o bandit-report.json || echo "Bandit security scan completed with warnings"
    
    # Install and run additional security tools
    - npm install -g snyk --no-fund --no-audit || echo "Snyk installation failed"
    - cd ../frontend && (snyk test --severity-threshold=high || echo "Frontend Snyk scan completed with warnings")
    - cd ../backend && (snyk test --severity-threshold=high || echo "Backend Snyk scan completed with warnings")
  artifacts:
    paths:
      - backend/bandit-report.json
    expire_in: 1 week
  allow_failure: true
  only:
    - merge_requests
    - main
    - develop

# Build stage with multi-stage Docker builds
build_application:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_BUILDKIT: 1
  before_script:
    - docker info
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    # Install Docker Compose
    - apk add --no-cache curl
    - curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
    - chmod +x /usr/local/bin/docker-compose
  script:
    # Build with automatic dependency installation
    - echo "Building application with automatic dependency installation..."
    
    # Create optimized Dockerfile if it doesn't exist
    - |
      if [ ! -f Dockerfile ]; then
        cat > Dockerfile << 'EOF'
      # Multi-stage build for production optimization
      FROM node:18-alpine AS frontend-builder
      WORKDIR /app/frontend
      RUN apk add --no-cache python3 make g++ git curl
      COPY frontend/package*.json ./
      RUN npm ci --only=production --no-audit --prefer-offline
      COPY frontend/ ./
      RUN npm run build --if-present || echo "No build script found"

      FROM python:3.11-alpine AS backend-builder  
      WORKDIR /app/backend
      RUN apk add --no-cache gcc musl-dev libffi-dev python3-dev build-base git curl
      COPY backend/requirements.txt ./
      RUN pip install --no-cache-dir -r requirements.txt
      COPY backend/ ./

      FROM nginx:alpine AS frontend-runtime
      RUN apk add --no-cache curl
      COPY --from=frontend-builder /app/frontend/dist /usr/share/nginx/html 2>/dev/null || true
      COPY --from=frontend-builder /app/frontend/build /usr/share/nginx/html 2>/dev/null || true
      COPY --from=frontend-builder /app/frontend/out /usr/share/nginx/html 2>/dev/null || true
      COPY --from=frontend-builder /app/frontend/.next/static /usr/share/nginx/html/_next/static 2>/dev/null || true
      COPY nginx/nginx.conf /etc/nginx/nginx.conf 2>/dev/null || echo "Using default config"
      RUN if [ ! -f /usr/share/nginx/html/index.html ]; then echo '<h1>Frontend Ready</h1>' > /usr/share/nginx/html/index.html; fi
      EXPOSE 80
      HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 CMD curl -f http://localhost/ || exit 1

      FROM python:3.11-alpine AS backend-runtime
      WORKDIR /app
      RUN apk add --no-cache curl bash dumb-init && addgroup -g 1001 -S appuser && adduser -S appuser -u 1001
      COPY --from=backend-builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
      COPY --from=backend-builder /usr/local/bin /usr/local/bin
      COPY --from=backend-builder /app/backend ./
      RUN chown -R appuser:appuser /app
      USER appuser
      EXPOSE 8000
      HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 CMD curl -f http://localhost:8000/health || exit 1
      ENTRYPOINT ["dumb-init", "--"]
      CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
      EOF
      fi
    
    # Build images with BuildKit for better caching
    - docker build --target frontend-runtime -t $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA .
    - docker build --target backend-runtime -t $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA .
    
    # Tag latest versions
    - docker tag $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/frontend:latest
    - docker tag $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/backend:latest
    
    # Push all images
    - docker push $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE/frontend:latest
    - docker push $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE/backend:latest
    
    # Build complete application stack
    - docker-compose -f docker-compose.production.yml build --parallel
    - docker-compose -f docker-compose.production.yml push
    
  artifacts:
    reports:
      dotenv: build.env
  only:
    - main
    - develop

# Deploy to staging with automatic setup
deploy_staging:
  stage: deploy
  image: alpine:latest
  before_script:
    # Install required tools
    - apk add --no-cache openssh-client curl
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $STAGING_SERVER >> ~/.ssh/known_hosts
  script:
    # Prepare deployment files
    - |
      cat > deploy.sh << 'EOF'
      #!/bin/bash
      set -e
      
      echo "🚀 Starting deployment to staging..."
      
      # Install Docker and Docker Compose if not present
      if ! command -v docker &> /dev/null; then
        echo "Installing Docker..."
        curl -fsSL https://get.docker.com -o get-docker.sh
        sudo sh get-docker.sh
        sudo usermod -aG docker $USER
        newgrp docker
      fi
      
      if ! command -v docker-compose &> /dev/null; then
        echo "Installing Docker Compose..."
        sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose
      fi
      
      # Install additional system dependencies
      if command -v apt-get &> /dev/null; then
        sudo apt-get update
        sudo apt-get install -y curl wget git
      elif command -v yum &> /dev/null; then
        sudo yum update -y
        sudo yum install -y curl wget git
      fi
      
      # Create project directory
      sudo mkdir -p $1
      sudo chown $USER:$USER $1
      cd $1
      
      # Login to registry
      echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
      
      # Pull latest images
      docker-compose pull
      
      # Stop existing containers gracefully
      docker-compose down --timeout 30
      
      # Clean up old containers and images
      docker container prune -f
      docker image prune -f
      
      # Start new containers
      docker-compose up -d --remove-orphans
      
      # Wait for services to be ready
      echo "Waiting for services to start..."
      sleep 45
      
      # Comprehensive health checks
      HEALTH_PASSED=true
      
      # Check backend health
      for i in {1..10}; do
        if curl -f --max-time 10 http://localhost:8000/health 2>/dev/null; then
          echo "✅ Backend health check passed"
          break
        elif [ $i -eq 10 ]; then
          echo "❌ Backend health check failed after 10 attempts"
          HEALTH_PASSED=false
        else
          echo "⏳ Backend health check attempt $i/10..."
          sleep 10
        fi
      done
      
      # Check frontend health
      for i in {1..10}; do
        if curl -f --max-time 10 http://localhost:3000 2>/dev/null || curl -f --max-time 10 http://localhost:80 2>/dev/null; then
          echo "✅ Frontend health check passed"
          break
        elif [ $i -eq 10 ]; then
          echo "❌ Frontend health check failed after 10 attempts"
          HEALTH_PASSED=false
        else
          echo "⏳ Frontend health check attempt $i/10..."
          sleep 10
        fi
      done
      
      # Show container status
      docker-compose ps
      
      if [ "$HEALTH_PASSED" = true ]; then
        echo "🎉 Deployment completed successfully!"
      else
        echo "⚠️ Deployment completed with health check warnings"
        docker-compose logs --tail=50
      fi
      EOF
    
    - chmod +x deploy.sh
    
    # Copy files to server and execute deployment
    - scp deploy.sh $STAGING_USER@$STAGING_SERVER:/tmp/
    - scp docker-compose.yml $STAGING_USER@$STAGING_SERVER:$STAGING_PATH/
    - ssh $STAGING_USER@$STAGING_SERVER "CI_REGISTRY=$CI_REGISTRY CI_REGISTRY_USER=$CI_REGISTRY_USER CI_REGISTRY_PASSWORD=$CI_REGISTRY_PASSWORD bash /tmp/deploy.sh $STAGING_PATH"
    
  environment:
    name: staging
    url: $STAGING_URL
  only:
    - develop

# Deploy to production with manual approval and rollback capability
deploy_production:
  stage: deploy
  image: alpine:latest
  before_script:
    # Install required tools
    - apk add --no-cache openssh-client curl
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $PRODUCTION_SERVER >> ~/.ssh/known_hosts
  script:
    # Production deployment with additional safety checks
    - |
      cat > production-deploy.sh << 'EOF'
      #!/bin/bash
      set -e
      
      echo "🚀 Starting production deployment..."
      
      # Create backup directory
      BACKUP_DIR="$1/backup-$(date +%Y%m%d_%H%M%S)"
      sudo mkdir -p $BACKUP_DIR
      
      # Backup current deployment
      if [ -f "$1/docker-compose.production.yml" ]; then
        sudo cp $1/docker-compose.production.yml $BACKUP_DIR/
        docker-compose -f $1/docker-compose.production.yml ps > $BACKUP_DIR/services.txt 2>/dev/null || true
        docker-compose -f $1/docker-compose.production.yml config > $BACKUP_DIR/config.yml 2>/dev/null || true
      fi
      
      # Install Docker and Docker Compose if not present
      if ! command -v docker &> /dev/null; then
        echo "Installing Docker..."
        curl -fsSL https://get.docker.com -o get-docker.sh
        sudo sh get-docker.sh
        sudo usermod -aG docker $USER
        newgrp docker
      fi
      
      if ! command -v docker-compose &> /dev/null; then
        echo "Installing Docker Compose..."
        sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose
      fi
      
      # Create project directory
      sudo mkdir -p $1
      sudo chown $USER:$USER $1
      cd $1
      
      # Login to registry
      echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
      
      # Pull latest images
      docker-compose -f docker-compose.production.yml pull
      
      # Rolling update with zero-downtime
      docker-compose -f docker-compose.production.yml up -d --no-deps --remove-orphans
      
      # Wait for services to be ready
      echo "Waiting for services to start..."
      sleep 90
      
      # Comprehensive health checks
      HEALTH_CHECK_PASSED=true
      
      # Backend health check with retry logic
      for i in {1..15}; do
        if curl -f --max-time 30 http://localhost:8000/health 2>/dev/null; then
          echo "✅ Backend health check passed"
          break
        elif [ $i -eq 15 ]; then
          echo "❌ Backend health check failed after 15 attempts"
          HEALTH_CHECK_PASSED=false
        else
          echo "⏳ Backend health check attempt $i/15..."
          sleep 20
        fi
      done
      
      # Frontend health check with retry logic
      for i in {1..15}; do
        if curl -f --max-time 30 http://localhost 2>/dev/null || curl -f --max-time 30 http://localhost:80 2>/dev/null; then
          echo "✅ Frontend health check passed"
          break
        elif [ $i -eq 15 ]; then
          echo "❌ Frontend health check failed after 15 attempts"
          HEALTH_CHECK_PASSED=false
        else
          echo "⏳ Frontend health check attempt $i/15..."
          sleep 20
        fi
      done
      
      if [ "$HEALTH_CHECK_PASSED" = false ]; then
        echo "🔄 Rolling back due to health check failures..."
        docker-compose -f docker-compose.production.yml down --timeout 30
        
        if [ -f "$BACKUP_DIR/docker-compose.production.yml" ]; then
          echo "Restoring previous version..."
          cp $BACKUP_DIR/docker-compose.production.yml $1/
          docker-compose -f docker-compose.production.yml up -d
          echo "Rollback completed"
        fi
        exit 1
      fi
      
      # Clean up old images and containers
      docker image prune -f --filter "until=24h"
      docker container prune -f
      
      # Show final status
      docker-compose -f docker-compose.production.yml ps
      
      echo "🎉 Production deployment completed successfully!"
      echo "Backup saved to: $BACKUP_DIR"
      EOF
    
    - chmod +x production-deploy.sh
    
    # Copy files to production server
    - scp production-deploy.sh $PRODUCTION_USER@$PRODUCTION_SERVER:/tmp/
    - scp docker-compose.production.yml $PRODUCTION_USER@$PRODUCTION_SERVER:$PRODUCTION_PATH/
    - ssh $PRODUCTION_USER@$PRODUCTION_SERVER "CI_REGISTRY=$CI_REGISTRY CI_REGISTRY_USER=$CI_REGISTRY_USER CI_REGISTRY_PASSWORD=$CI_REGISTRY_PASSWORD bash /tmp/production-deploy.sh $PRODUCTION_PATH"
    
  environment:
    name: production
    url: $PRODUCTION_URL
  when: manual
  only:
    - main

# Cleanup job to remove old artifacts and images
cleanup:
  stage: deploy
  image: alpine:latest
  script:
    - echo "🧹 Cleaning up old artifacts and cache..."
    - echo "This job runs after deployments to clean up resources"
    - echo "In a real environment, this would clean up old Docker images and artifacts"
  when: always
  only:
    - main
    - develop